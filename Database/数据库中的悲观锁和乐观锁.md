#### 数据库中的悲观锁和乐观锁



昨天在看数据库ACID中的隔离性(isolation)。隔离性，也就是说数据库中多个事务并行执行后的状态，和他们串行执行后的状态应该是一致的。但是如何实现隔离性呢，主要就是以下这两种锁：



* 悲观锁 (适用于多写的情况)

  总是认为别的事务会修改数据，于是就将当前操作的对象加锁，等待操作完成后释放锁。

  为了提高性能，我们发明了各种粒度(数据级、表级、行级) 和 各种性质(共享锁、排他锁、意向锁)

  * 共享锁 (读锁)  也称为S锁

    如果事务T给数据A上了S锁，则其他事务只能继续对A上S锁，不能上X锁。

    也就是说，上了读锁，别的事务可以继续读A，但是却不能写A。

  * 排他锁 (写锁) 也称为X锁

    如果事务T给数据A上了X锁，则其他事务既不可以给A上S锁，也不可以给A上X锁。

    也就是说，上了写锁，别的事务既不可以读A，也不可以写A。

  * 意向锁

    InnoDB自动加的，不需要用户干预。

    IS锁，表示事务准备给数据加S锁。--> 取得S锁之前，必须先取得IS锁。

    IX锁，表示事务准备给数据加X锁。--> 取得X锁之前，必须先取得IX锁。

  

* 乐观锁 (适用于多读的情况)

  总是认为别的事务不会修改数据。有以下两种实现机制：

  * version机制 (CAS)

    在数据表中为数据增加一个version字段，表示数据被修改的次数。当数据被修改时，version字段加一。

    e.g. 当线程T在修改数据A时，先读取数据A以及A的version，修改A，version++。在提交更新时，check要提交的version数值是否比当前的version数值要大。提交成功。 

    * CAS (compare and swap)

      CAS讲的是自增这种操作，其实并不是原子的。会产生ABA问题。

      也就是说，中间被修改过，然后又被修改回原值，这种情况我们并不能检查出来。

      